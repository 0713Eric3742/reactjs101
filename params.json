{
  "name": "從零開始學 React（React 101）",
  "tagline": "一本給初學者的 React 入門教學書，由淺入深學習 ReactJS 生態系 (React, Flux, Redux, React Native, etc.)",
  "body": "\r\n## 目錄（Agenda）\r\n\r\n* [一、前端工程和 React 生態系簡介](#f2e-and-react-ecosystem)\r\n\r\n* 二、React/JSX/Component 簡介\r\n\r\n* 三、開發環境設置與 Webpack 入門\r\n\r\n* 四、Pros/State 基礎\r\n\r\n* 五、Component 生命週期\r\n\r\n* 六、事件處理\r\n\r\n* 七、DOM 操作\r\n\r\n* 八、表單處理\r\n\r\n* 九、Routing\r\n\r\n* 十、Flux/Redux\r\n\r\n* 十一、React Native 簡介\r\n\r\n* 十二、範例練習：用 React + Rudux 寫一個 Todo List\r\n\r\n* 十三、範例練習：用 React + Node（Express.js） 開發微網誌系統\r\n\r\n* 十四、範例練習：用 React Native 寫一個新聞閱讀器\r\n\r\n* [附錄一、React ES5、ES6+ 常見用法對照表](#react-react-native-es5-es6-cheat-sheet)\r\n\r\n* 附錄二、學習資源\r\n\r\n<h2 id=\"f2e-and-react-ecosystem\">一、前端工程和 React 生態系簡介</h2>\r\n\r\n## 前言\r\n隨著現代化網站（Modern Web）開發專業和複雜性的提昇以及對於使用者體驗的要求下，網站開發已從過去的Web Develpoer（或現在我們稱的Full Stack Engineer）一夫當關，轉向專業分工，更加細分成網頁前端（Web Front End）、網頁後端（Web Back End）等職位。此外，由於跨平台、跨瀏覽器的需求日益增加，技術變化更迭快速，市場上對於前端工程師（Web Front End Engineer）的需求也與日俱增，前端工程的（Front End Engineering）挑戰也越來越多。\r\n\r\n## 前端工程範疇\r\nHTML、CSS 和 JavaScript 是前端工程最重要的技術元素。過去一段時間，我們所認為的前端工程主要專注在瀏覽器平台，但現在的 Web 平台已經不侷限於桌面瀏覽器，更多的跨平台、跨瀏覽器的應用開發，其中包含：\r\n\r\n1. 網頁瀏覽器（Web Browser），一般的網頁應用程式開發\r\n2. 透過 CLI 指令去操作的 Headless 瀏覽器（Headless　Application）。例如：phantomJS、CasperJS\r\n3. 運作在 WebView 瀏覽器核心（WebView Application）的應用。例如：Apache Cordova、Electron、NW.js\r\n4. 原生應用程式（Native Application），透過 Web 技術撰寫原生應用程式。例如：React Native、Native Script\r\n\r\n過去幾年，前端開發就像經歷了文藝復興（Rinascimento）的年代，開始了各種框架、套件百花齊放的時代。雖然現在有更多好用工具可以協助開發，但前端工程師似乎並沒有變得比較輕鬆。以往若能妥善運用 jQuery 等函式庫就可以應付大部分前端工程師的工作，但現在前端徵人廣告上不僅要求精通 HTML、CSS 和 JavaScript，還要對於還要對於 Backbone、Ember、Angular、React 等 JavaScript 框架或函式庫有一定程度的了解。\r\n\r\n其中 [React](https://facebook.github.io/react/) 是 Facebook 推出的開源 [JavaScript](https://en.wikipedia.org/wiki/JavaScript) Library，它的出現帶出了許多革新性的 Web 觀念開始流行，例如：Virtual DOM、Web Component 等。而自從 React 於 2013 年正式開源後，React 生態系開始蓬勃發展。事實上，透過學習 React 生態系（ecosystem）的過程中，可以讓我們順便學習現代化 Web 開發的重要觀念（例如：ES6、[Webpack](https://github.com/webpack/webpack)、[Bable](https://babeljs.io/)、模組化等）。本書筆者主要是希望藉由一個整合 Github API 的應用範例深入淺出的教學介紹 ReactJS 生態系，並帶領讀者們探討前端工程中軟體工程的部份。\r\n\r\n\r\n<h2 id=\"react-react-native-es5-es6-cheat-sheet\">附錄一、React ES5、ES6+ 常見用法對照表</h2>\r\n\r\n## 前言\r\n[React](https://facebook.github.io/react/) 是 Facebook 推出的開源 [JavaScript](https://en.wikipedia.org/wiki/JavaScript) Library。自從 React 正式開源後，React 生態系開始蓬勃發展。事實上，透過學習 React 生態系（ecosystem）的過程中，可以讓我們順便學習現代化 Web 開發的重要觀念（例如：ES6、[Webpack](https://github.com/webpack/webpack)、[Babel](https://babeljs.io/)、模組化等），成為更好的開發者。雖然 ES6（ECMAScript2015）、ES7 是未來趨勢（本文將 ES6、ES7 稱為 ES6+），然而目前在網路上有許多的學習資源仍是以 ES5 為主，導致讀者在學習上遇到一些坑洞和迷惑（本文假設讀者對於 React 已經有些基本認識，若你對於 React 尚不熟悉，建議先行[閱讀官方文件](https://facebook.github.io/react/)和[本篇入門教學](https://scotch.io/tutorials/learning-react-getting-started-and-concepts)）。因此本文希望透過整理在 React 中 ES5、ES6+ 常見用法對照表，讓讀者們可以在實現功能時（尤其在 [React Native](https://facebook.github.io/react-native/)）可以更清楚兩者的差異，無痛轉移到 ES6+。 \r\n\r\n## 大綱\r\n1. Modules\r\n2. Classes\r\n3. Method definition\r\n4. Property initializers\r\n5. State\r\n6. Arrow functions\r\n7. Dynamic property names & template strings\r\n8. Destructuring & spread attributes\r\n9. Mixins\r\n10. Default Parameters\r\n\r\n## 1. Modules\r\n隨著 Web 技術的進展，模組化開發已經成為一個重要課題。關於 JavaScript 模組化我們這邊不詳述，建議讀者參考 [這份投影片](http://huangxuan.me/js-module-7day/#/) 和 [這篇文章](http://justineo.github.io/singles/writing-modular-js/)。\r\n\r\nES5 若使用 CommonJS 標準，一般使用 `require()` 用法引入模組：\r\n\r\n```js\r\nvar React = require('react');\r\nvar MyComponent = require('./MyComponent');\r\n```\r\n\r\n輸出則是使用 `module.exports`：\r\n\r\n```js\r\nmodule.exports = MyComponent;\r\n```\r\n\r\n\r\nES6+ `import` 用法：\r\n\r\n```js\r\nimport React from 'react';\r\nimport MyComponent from './MyComponent';\r\n```\r\n\r\n輸出則是使用 `export default`：\r\n\r\n```js\r\nexport default class MyComponent extends React.Compoent {\r\n\t\r\n}\r\n```\r\n\r\n\r\n## 2. Classes\r\n在 React 中元件（Component）是組成視覺頁面的基礎。在 ES5 中我們使用 `React.createClass()` 來建立 Component，而在 ES6+ 則是用 [Classes](https://babeljs.io/docs/learn-es2015/#classes) 繼承 `React.Component` 來建立 Component。若是有寫過 Java 等物件導向語言（OOP）的讀者應該對於這種寫法比較不陌生，不過要注意的是 JavaScript 仍是原型繼承類型的物件導向程式語言，只是使用 `Classes` 讓物件導向使用上更加直觀。對於選擇 `class` 使用上還有疑惑的讀者建議可以閱讀 [React.createClass versus extends React.Component](https://toddmotto.com/react-create-class-versus-component/) 這篇文章。\r\n\r\nES5 `React.createClass()` 用法：\r\n\r\n```js \r\nvar Photo = React.createClass({\r\n  render: function() {\r\n    return (\r\n    \t<div>\r\n    \t\t<img alt={this.props.description} src={this.props.src} />\r\n    \t</div>\r\n    \t);\r\n  }\r\n});\r\nReactDOM.render(<Photo />, document.getElementById('main'));\r\n```\r\n\r\nES6+ `class` 用法：\r\n\r\n```js \r\nclass Photo extends React.Component {\r\n  render() {\r\n    return <img alt={this.props.description} src={this.props.src} />;\r\n  }\r\n}\r\nReactDOM.render(<Photo />, document.getElementById('main'));\r\n```\r\n\r\n在 ES5 我們會在 `componentWillMount ` 生命週期定義希望在 `render` 前執行，且只會執行一次的任務：\r\n \r\n```js\r\nvar Photo = React.createClass({\r\n  componentWillMount: function() {}\r\n});\r\n```\r\n\r\n在 ES6+ 則是定義在 `constructor ` 建構子中：\r\n\r\n```js\r\nclass Photo extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    // 原本在 componentWillMount 操作的動作可以放在這\r\n  }\r\n}\r\n```\r\n\r\n## 3. Method definition\r\n在 ES6 中我們使用 `Method` 可以忽略 `function` 和 `,`，使用上更為簡潔！ES5 `React.createClass()` 用法：\r\n\r\n```js\r\nvar Photo = React.createClass({\r\n  handleClick: function(e) {},\r\n  render: function() {}\r\n});\r\n```\r\n\r\nES6+ class 用法：\r\n\r\n```js\r\nclass Photo extends React.Component {\r\n  handleClick(e) {}\r\n  render() {}\r\n}\r\n```\r\n\r\n\r\n## 4. Property initializers\r\nComponent 屬性值是資料傳遞重要的元素，在 ES5 中我們使用 `propTypes ` 和  `getDefaultProps ` 來定義屬性（props）的預設值和型別：\r\n\r\n```js\r\nvar Todo = React.createClass({\r\n  getDefaultProps: function() {\r\n    return {\r\n      checked: false,\r\n      maxLength: 10,\r\n    };\r\n  },\r\n  propTypes: {\r\n    checked: React.PropTypes.bool.isRequired,\r\n    maxLength: React.PropTypes.number.isRequired\r\n  },\r\n  render: fucntion() {\r\n  \treturn();\r\n  }\r\n});\r\n```\r\n\r\n在 ES6+ 中我們則是參考 [ES7 property initializers](https://github.com/jeffmo/es-class-fields-and-static-properties) 使用 `class` 中的靜態屬性（static properties）來定義：\r\n\r\n```js\r\nclass Todo extends React.Component {\r\n  static defaultProps = {\r\n    checked: false,\r\n    maxLength: 10,\r\n  }; // 注意有分號\r\n  static propTypes = {\r\n    checked: React.PropTypes.bool.isRequired,\r\n    maxLength: React.PropTypes.number.isRequired\r\n  };\r\n  render() {\r\n  \treturn();\r\n  }\r\n}\r\n```\r\n\r\nES6+ 另外一種寫法，可以留意一下，主要是看各團隊喜好和規範，選擇合適的方式：\r\n\r\n```js\r\nclass Todo extends React.Component {\r\n    render() {\r\n        return (\r\n            <View />\r\n        );\r\n    }\r\n}\r\nTodo.defaultProps = {\r\n    checked: false,\r\n    maxLength: 10,\r\n};\r\nTodo.propTypes = {\r\n    checked: React.PropTypes.bool.isRequired,\r\n    maxLength: React.PropTypes.number.isRequired,\r\n};\r\n```\r\n\r\n\r\n## 5. State\r\n在 React 中 `Props` 和 `State` 是資料流傳遞的重要元素，不同的是 `state` 可更動，可以去執行一些運算。在 ES5 中我們使用 `getInitialState ` 去初始化 `state`： \r\n \r\n```js\r\nvar Todo = React.createClass({\r\n    getInitialState: function() {\r\n        return {\r\n            maxLength: this.props.maxLength,\r\n        };\r\n    },\r\n});\r\n```\r\n\r\n在 ES6+ 中我們初始化 `state` 有兩種寫法：\r\n\r\n```js\r\nclass Todo extends React.Component {\r\n    state = {\r\n        maxLength: this.props.maxLength,\r\n    }\r\n}\r\n```\r\n\r\n另外一種寫法，使用在建構式初始化。比較推薦使用這種方式，方便做一些運算：\r\n\r\n```js\r\nclass Todo extends React.Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            maxLength: this.props.maxLength,\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 6. Arrow functions\r\n\r\n在講 `Arrow functions` 之前，我們先聊聊在 React 中 `this` 和它所代表的 `context`。在 ES5 中，我們使用 `React.createClass()` 來建立 Component，而在 `React.createClass()` 下，預設幫你綁定好 `method` 的 `this`，你毋須自行綁定。所以你可以看到像是下面的例子，`callback function` handleButtonClick 中的  `this` 是指到 component 的實例（instance），而非觸發事件的物件：\r\n\r\n```js\r\nvar TodoBtn = React.createClass({\r\n    handleButtonClick: function(e) {\r\n        // 此 this 指到 component 的實例（instance），而非 button\r\n        this.setState({showOptionsModal: true});\r\n    },\r\n    render: function(){\r\n        return (\r\n            <div>\r\n                <Button onClick={this.handleButtonClick}>{this.props.label}</Button>\r\n            </div>\r\n        )\r\n    },\r\n});\r\n```\r\n\r\n然而自動綁定這種方式反而會讓人容易誤解，所以在 ES6+ 推薦使用 `bind ` 綁定 `this` 或使用 `Arrow functions`（它會绑定當前 `scope` 的 `this context`）兩種方式，你可以參考下面例子：\r\n\r\n```js\r\nclass TodoBtn extends React.Component\r\n{\r\n    handleButtonClick(e){\r\n        // 確認綁定 this 指到 component instance\r\n        this.setState({toggle: true});\r\n    }\r\n    render(){\r\n        // 這邊可以用 this.handleButtonClick.bind(this) 手動綁定或是 Arrow functions () => {} 用法\r\n        return (\r\n            <div>\r\n                <Button onClick={this.handleButtonClick.bind(this)} onClick={(e)=> {this.handleButtonClick(e)} }>{this.props.label}</Button>\r\n            </div>\r\n        )\r\n    },\r\n}\r\n```\r\n\r\n`Arrow functions` 雖然一開始看起來有點怪異，但其實觀念很簡單：一個簡化的函數。函數基本上就是參數（不一定要有參數）、表達式、回傳值（也可能是回傳 undefined）：\r\n\r\n```\r\n// Arrow functions 的一些例子\r\n()=>7\r\ne=>e+2\r\n()=>{\r\n    alert('XD');\r\n}\r\n(a,b)=>a+b\r\ne=>{\r\n    if (e == 2){\r\n        return 2;\r\n    }\r\n    return 100/e;\r\n}\r\n```\r\n\r\n不過要注意的是無論是 `bind` 或是 `Arrow functions`，每次執行回傳都是指到一個新的函數，若需要再調用到這個函數，請記得先把它存起來：\r\n\r\n錯誤用法：\r\n\r\n```js\r\nclass TodoBtn extends React.Component{\r\n    componentWillMount(){\r\n        Btn.addEventListener('click', this.handleButtonClick.bind(this));\r\n    }\r\n    componentDidmount(){\r\n        Btn.removeEventListener('click', this.handleButtonClick.bind(this));\r\n    }\r\n    onAppPaused(event){\r\n    }\r\n}\r\n```\r\n\r\n正確用法：\r\n\r\n```js\r\nclass TodoBtn extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.handleButtonClick = this.handleButtonClick.bind(this);\r\n    }\r\n    componentWillMount(){\r\n        Btn.addEventListener('click', this.handleButtonClick);\r\n    }\r\n    componentDidmount(){\r\n        Btn.removeEventListener('click', this.handleButtonClick);\r\n    }\r\n}\r\n```\r\n\r\n更多 Arrows and Lexical This 特性可以[參考這個文件](https://babeljs.io/docs/learn-es2015/#arrows)。\r\n\r\n\r\n## 7. Dynamic property names & template strings\r\n以前在 ES5 我們要動態設定屬性名稱時，往往需要多寫幾行程式碼才能達到目標：\r\n\r\n```js\r\nvar Todo = React.createClass({\r\n  onChange: function(inputName, e) {\r\n    var stateToSet = {};\r\n    stateToSet[inputName + 'Value'] = e.target.value;\r\n    this.setState(stateToSet);\r\n  },\r\n});\r\n```\r\n\r\n但在 ES6+中，透過 [enhancements to object literals](https://babeljs.io/blog/2015/06/07/react-on-es6-plus) 和 [template strings](https://babeljs.io/docs/learn-es2015/#template-strings) 可以輕鬆完成動態設定屬性名稱的任務：\r\n\r\n```\r\nclass Todo extends React.Component {\r\n  onChange(inputName, e) {\r\n    this.setState({\r\n      [`${inputName}Value`]: e.target.value,\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nTemplate Strings 是一種語法糖（syntactic sugar），方便我們組織字串：\r\n\r\n```js\r\n// Interpolate variable bindings\r\nvar name = \"Bob\", time = \"today\";\r\n`Hello ${name}, how are you ${time}?` \\\\ Hello Bob, how are you today?\r\n```\r\n\r\n\r\n## 8. Destructuring & spread attributes\r\n在 React 的 Component 中，父元件利用 `props` 來傳遞資料到子元件是常見作法，然而我們有時會希望只傳遞部分資料，此時 ES6+ 中的 [Destructuring](https://babeljs.io/docs/learn-es2015/#destructuring) 和 [JSX 的 Spread Attributes\r\n](https://facebook.github.io/react/docs/jsx-spread.html) 就可以幫我們達到目標：\r\n\r\n```js\r\nclass Todo extends React.Component {\r\n  render() {\r\n    var {\r\n      className,\r\n      ...others,  // contains all properties of this.props except for className\r\n    } = this.props;\r\n    return (\r\n      <div className={className}>\r\n        <TodoList {...others} />\r\n        <button onClick={this.handleLoadMoreClick}>Load more</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n但使用上要注意的是若是有重複的屬性值則以後來覆蓋，下面的例子中若 `...this.props`，有 `className`，則被後來的 `main` 所覆蓋：\r\n\r\n```js\r\n<div {...this.props} className=\"main\">\r\n  …\r\n</div>\r\n```\r\n\r\n而 `Destructuring` 也可以用在簡化 `Module` 的引入上，這邊我們先用 ES5 中引入方式來看：\r\n\r\n```js\r\nvar React = require('react-native');\r\nvar Component = React.component;\r\n \r\nclass HelloWorld extends Component {\r\n  render() {\r\n    return (\r\n      <View>\r\n        <Text>Hello, world!</Text>\r\n      </View>\r\n    );\r\n  }\r\n}\r\n \r\nexport default HelloWorld;\r\n```\r\n\r\n在 ES6+ 則可以直接使用 `Destructuring` 來引入模組中的元件：\r\n\r\n```js\r\nimport React, {\r\n\tView,\r\n\tComponent,\r\n\tImage\r\n} from 'react-native';\r\n \r\nclass HelloWorld extends Component {\r\n  render() {\r\n    return (\r\n      <View>\r\n        <Text>Hello, world!</Text>\r\n      </View>\r\n    );\r\n  }\r\n}\r\n \r\nexport default HelloWorld;\r\n```\r\n\r\n\r\n## 9. Mixins\r\n在 ES5 中，我們可以使用 `Mixins` 的方式去讓不同的 Component 共用相似的功能，重用我們的程式碼：\r\n\r\n```js\r\nvar PureRenderMixin = require('react-addons-pure-render-mixin');\r\nReact.createClass({\r\n  mixins: [PureRenderMixin],\r\n\r\n  render: function() {\r\n    return <div className={this.props.className}>foo</div>;\r\n  }\r\n});\r\n```\r\n\r\n但由於官方不打算在 ES6+ 中繼續推行 `Mixins`，若還是希望使用，可以參考看看[第三方套件](https://www.npmjs.com/package/es6-class-mixin)或是[這個文件的用法](https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775)。\r\n\r\n## 10. Default Parameters\r\n以前 ES5 我們函數要使用預設值需要這樣使用：\r\n\r\n```js\r\nvar link = function (height, color) {  \r\n    var height = height || 50;  \r\n    var color = color || 'red';  \r\n}  \r\n```\r\n\r\n現在 ES6+ 的函數可以支援預設值，讓程式碼更為簡潔：\r\n\r\n```js\r\nvar link = function(height = 50, color = 'red') {  \r\n  ...  \r\n} \r\n```\r\n\r\n## 總結\r\n以上就是 React ES5、ES6+常見用法對照表，能看到這邊的你應該已經對於 React ES5、ES6 使用上有些認識，先給自己一些掌聲吧！確實從 ES6 開始，JavaScript 和以前我們看到的 JavaScript 有些不同，增加了許多新的特性，有些讀者甚至會很懷疑說這真的是 JavaScript 嗎？ES6 的用法對於初學者來說可能會需要寫一點時間吸收，下面我幫大家準備了延伸閱讀，方便大家進一步參考學習。接下來我們也會有一系列從零開始學 React 的文章來帶大家由淺入深學習 ReactJS 生態系，運用 JavaScript 打造跨平台應用程式。筆者才書學淺，若有疏漏歡迎大家一起交流討論：）\r\n\r\n## 延伸閱讀\r\n1. [React/React Native 的ES5 ES6写法对照表](http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8)\r\n2. [React on ES6+](https://babeljs.io/blog/2015/06/07/react-on-es6-plus)\r\n3. [react native 中es6语法解析](http://www.ghugo.com/react-native-es6/) \r\n4. [Learn ES2015](https://babeljs.io/docs/learn-es2015/)\r\n5. [ECMAScript 6入门](http://es6.ruanyifeng.com/)\r\n6. [React官方網站](https://facebook.github.io/react/index.html)\r\n7. [React INTRO TO REACT.JS](http://fraserxu.me/intro-to-react/)\r\n8. [React.createClass versus extends React.Component](https://toddmotto.com/react-create-class-versus-component/)\r\n9. [react-native-coding-style](https://github.com/lzbSun/react-native-coding-style)\r\n10. [Airbnb React/JSX Style Guide](https://github.com/airbnb/javascript/tree/master/react)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}